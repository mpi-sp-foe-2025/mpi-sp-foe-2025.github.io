<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>References: Typing Mutable References</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/plf.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="common/slides.js"></script>
<link href="common/css/slides.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 2: Programming Language Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">References<span class="subtitle">Typing Mutable References</span></h1>


<div class="doc">

<div class="paragraph"> </div>

 Most real languages include <i>impure</i>
    features ("computational effects")...
<ul class="doclist">
<li> mutable pointer structures

</li>
<li> non-local control constructs (exceptions, continuations, etc.)

</li>
<li> process synchronization and communication

</li>
<li> etc.

</li>
</ul>

<div class="paragraph"> </div>

    Goal for this chapter: formalize pointers. 
</div>

<div class="doc">
<a id="lab413"></a><h1 class="section">Definitions</h1>

<div class="paragraph"> </div>

 In most real-world programming languages, the mechanisms of
    <i>name binding</i> and <i>storage allocation</i> are (intentionally)
    confused: every name refers to a mutable piece of storage.

<div class="paragraph"> </div>

    Conceptually, it's cleaner to separate the two:
<ul class="doclist">
<li> use the mechanisms we already have for name binding
         (abstraction, let);

</li>
<li> introduce new, explicit operations for allocating, changing,
         and looking up the contents of references (pointers). 

</li>
</ul>
</div>

<div class="doc">
<a id="lab414"></a><h1 class="section">Syntax</h1>

</div>

<div class="doc">
The basic operations on references are <i>allocation</i>,
    <i>dereferencing</i>, and <i>assignment</i>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> To allocate a reference, we use the <span class="inlinecode"><span class="id" title="var">ref</span></span> operator, providing
         an initial value for the new cell.

<div class="paragraph"> </div>

         For example, <span class="inlinecode"><span class="id" title="var">ref</span></span> <span class="inlinecode">5</span> creates a new cell containing the value
         <span class="inlinecode">5</span>, and reduces to a reference to that cell.

<div class="paragraph"> </div>


</li>
<li> To read the current value of this cell, we use the
         dereferencing operator <span class="inlinecode">!</span>.

<div class="paragraph"> </div>

         For example, <span class="inlinecode">!(<span class="id" title="var">ref</span></span> <span class="inlinecode">5)</span> reduces to <span class="inlinecode">5</span>.

<div class="paragraph"> </div>


</li>
<li> To change the value stored in a cell, we use the assignment
         operator.

<div class="paragraph"> </div>

         If <span class="inlinecode"><span class="id" title="var">r</span></span> is a reference, <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">7</span> will store the value <span class="inlinecode">7</span> in
         the cell referenced by <span class="inlinecode"><span class="id" title="var">r</span></span>. 

</li>
</ul>
</div>

<div class="doc">
<a id="lab415"></a><h3 class="section">Types</h3>

<div class="paragraph"> </div>

 If <span class="inlinecode"><span class="id" title="var">T</span></span> is a type, then <span class="inlinecode"><span class="id" title="var">Ref</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span> is the type of references to
    cells holding values of type <span class="inlinecode"><span class="id" title="var">T</span></span>.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">T</span> <span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>:</span>:</span>=</span> <span class="id" title="var">Nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Unit</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">T</span> → <span class="id" title="var">T</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Ref</span> <span class="id" title="var">T</span>
</span>
</div>

<div class="doc">
<a id="lab416"></a><h3 class="section">Terms</h3>

<div class="paragraph"> </div>

 Besides the usual variables, abstractions, applications,
    terms related to natural numbers, and <span class="inlinecode"><span class="id" title="var">unit</span></span>, we need four
    more sorts of terms in order to handle mutable references:
<pre>
      t <span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>:</span>:</span>=</span> ...              Terms
          | ref t              allocation
          | !t                 dereference
          | t := t             assignment
          | l                  location
</pre>

</div>

<div class="doc">
<a id="lab417"></a><h3 class="section">Typing (Preview)</h3>

<div class="paragraph"> </div>

 Informally, the typing rules for allocation, dereferencing, and
    assignment will look like this:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Gamma <span class="nowrap">&vert;--</span> t<sub>1</sub> &#x2208; T<sub>1</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (T_Ref) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma <span class="nowrap">&vert;--</span> ref t<sub>1</sub> &#x2208; Ref T<sub>1</sub></td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Gamma <span class="nowrap">&vert;--</span> t<sub>1</sub> &#x2208; Ref T<sub>1</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (T_Deref) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma <span class="nowrap">&vert;--</span> !t<sub>1</sub> &#x2208; T<sub>1</sub></td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Gamma <span class="nowrap">&vert;--</span> t<sub>1</sub> &#x2208; Ref T<sub>2</sub></td>
  <td></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma <span class="nowrap">&vert;--</span> t<sub>2</sub> &#x2208; T<sub>2</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (T_Assign) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma <span class="nowrap">&vert;--</span> t<sub>1</sub> := t<sub>2</sub> : Unit</td>
  <td></td>
</tr>
</table></center>    The rule for locations will require a bit more machinery, and this
    will motivate some changes to the other rules; we'll come back to
    this later. 
</div>

<div class="doc">
<a id="lab418"></a><h3 class="section">Values and Substitution</h3>

<div class="paragraph"> </div>

 Besides abstractions, numbers, and the unit value, we have one new
    type of value: locations.  
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">value</span> : <span class="id" title="var">tm</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">v_abs</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">T<sub>2</sub></span> <span class="id" title="var">t<sub>1</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">value</span> &lt;{\<span class="id" title="var">x</span>:<span class="id" title="var">T<sub>2</sub></span>, <span class="id" title="var">t<sub>1</sub></span>}&gt;<br/>
&nbsp;&nbsp;| <span class="id" title="var">v_nat</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">value</span> &lt;{ <span class="id" title="var">n</span> }&gt;<br/>
&nbsp;&nbsp;| <span class="id" title="var">v_unit</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">value</span> &lt;{ <span class="id" title="var">unit</span> }&gt;<br/>
&nbsp;&nbsp;| <span class="id" title="var">v_loc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">value</span> &lt;{ <span class="id" title="var">loc</span> <span class="id" title="var">l</span> }&gt;.<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab419"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Extending substitution to handle the new syntax of terms is
    straightforward: substituting in a pointer leaves it
    unchanged.  
</div>

<div class="doc">
<a id="lab420"></a><h1 class="section">Pragmatics</h1>

</div>

<div class="doc">
<a id="lab421"></a><h2 class="section">Side Effects and Sequencing</h2>

<div class="paragraph"> </div>

 We can write (for example)
<pre>
       r:=succ(!r); !r
</pre>
   as an abbreviation for
<pre>
       (\x:Unit, !r) (r := succ(!r)).
</pre>

</div>

<div class="doc">
<a id="lab422"></a><h2 class="section">References and Aliasing</h2>

<div class="paragraph"> </div>

 It is important to bear in mind the difference between the
    <i>reference</i> that is bound to some variable <span class="inlinecode"><span class="id" title="var">r</span></span> and the <i>cell</i>
    in the store that is pointed to by this reference.

<div class="paragraph"> </div>

    If we make a copy of <span class="inlinecode"><span class="id" title="var">r</span></span>, for example by binding its value to
    another variable <span class="inlinecode"><span class="id" title="var">s</span></span>, what gets copied is only the <i>reference</i>,
    not the contents of the cell itself.

<div class="paragraph"> </div>

    For example, after reducing
<pre>
      let r = ref 5 in
      let s = r in
      s := 82;
      (!r)+1
</pre>
    the cell referenced by <span class="inlinecode"><span class="id" title="var">r</span></span> will contain the value <span class="inlinecode">82</span>, while the
    result of the whole expression will be <span class="inlinecode">83</span>.  The references <span class="inlinecode"><span class="id" title="var">r</span></span>
    and <span class="inlinecode"><span class="id" title="var">s</span></span> are said to be <i>aliases</i> for the same cell. 
<div class="paragraph"> </div>

<a id="lab423"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 The possibility of aliasing can make programs with references
    quite tricky to reason about.  For example, the expression
<pre>
      r := 5; r := !s
</pre>
    assigns <span class="inlinecode">5</span> to <span class="inlinecode"><span class="id" title="var">r</span></span> and then immediately overwrites it with <span class="inlinecode"><span class="id" title="var">s</span></span>'s
    current value; this has exactly the same effect as the single
    assignment
<pre>
      r := !s
</pre>
    <i>unless</i> we happen to do it in a context where <span class="inlinecode"><span class="id" title="var">r</span></span> and <span class="inlinecode"><span class="id" title="var">s</span></span> are
    aliases for the same cell!
<pre>
      let r = ref 0 in
      let s = r in
      r := 5; r := !s
</pre>

</div>

<div class="doc">
<a id="lab424"></a><h2 class="section">Shared State</h2>

<div class="paragraph"> </div>

 Of course, aliasing is also a large part of what makes references
    useful.  In particular, it allows us to set up "implicit
    communication channels" -- shared state -- between different parts
    of a program.  For example, suppose we define a reference cell and
    two functions that manipulate its contents:
<pre>
      let c = ref 0 in
      let incc = \_:Unit, (c := succ (!c); !c) in
      let decc = \_:Unit, (c := pred (!c); !c) in
      ...
</pre>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="var">Unit</span></span>-abstractions ("thunks") are used here to prevent
    reduction until later. 
</div>

<div class="doc">
<a id="lab425"></a><h2 class="section">Objects</h2>

<div class="paragraph"> </div>

 We can go a step further and write a <i>function</i> that creates <span class="inlinecode"><span class="id" title="var">c</span></span>,
    <span class="inlinecode"><span class="id" title="var">incc</span></span>, and <span class="inlinecode"><span class="id" title="var">decc</span></span>, packages <span class="inlinecode"><span class="id" title="var">incc</span></span> and <span class="inlinecode"><span class="id" title="var">decc</span></span> together into a
    record, and returns this record:
<pre>
      newcounter =
          \_:Unit,
             let c = ref 0 in
             let incc = \_:Unit, (c := succ (!c); !c) in
             let decc = \_:Unit, (c := pred (!c); !c) in
             {i=incc, d=decc}
</pre>

<div class="paragraph"> </div>

<a id="lab426"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Now, each time we call <span class="inlinecode"><span class="id" title="var">newcounter</span></span>, we get a new record of
    functions that share access to the same storage cell <span class="inlinecode"><span class="id" title="var">c</span></span>.  The
    caller of <span class="inlinecode"><span class="id" title="var">newcounter</span></span> can't get at this storage cell directly,
    but can affect it indirectly by calling the two functions.  In
    other words, we've created a simple form of <i>object</i>.
<pre>
      let c<sub>1</sub> = newcounter unit in
      let c<sub>2</sub> = newcounter unit in
      // Note that we've allocated two separate storage cells now!
      let r<sub>1</sub> = c<sub>1</sub>.i unit in
      let r<sub>2</sub> = c<sub>2</sub>.i unit in
      r<sub>2</sub>  // yields 1, not 2!
</pre>
 
</div>

<div class="doc">
<a id="lab427"></a><h2 class="section">References to Compound Types</h2>

<div class="paragraph"> </div>

 A reference cell need not contain just a number: the primitives
    we've defined above allow us to create references to values of any
    type, including functions.  For example, we can use references to
    functions to give an (inefficient) implementation of arrays
    of numbers, as follows.

<div class="paragraph"> </div>

    Write <span class="inlinecode"><span class="id" title="var">NatArray</span></span> for the type <span class="inlinecode"><span class="id" title="var">Ref</span></span> <span class="inlinecode">(<span class="id" title="var">Nat</span>→<span class="id" title="var">Nat</span>)</span>. 
<div class="paragraph"> </div>

<a id="lab428"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 To build a new array, we allocate a reference cell and fill
    it with a function that, when given an index, always returns <span class="inlinecode">0</span>.
<pre>
      newarray = \_:Unit, ref (\n:Nat,0)
</pre>

<div class="paragraph"> </div>

<a id="lab429"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 To look up an element of an array, we simply apply
    the function to the desired index.
<pre>
      lookup = \a:NatArray, \n:Nat, (!a) n
</pre>

<div class="paragraph"> </div>

<a id="lab430"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 The interesting part of the encoding is the <span class="inlinecode"><span class="id" title="var">update</span></span> function.  It
    takes an array, an index, and a new value to be stored at that index, and
    does its job by creating (and storing in the reference) a new function
    that, when it is asked for the value at this very index, returns the new
    value that was given to <span class="inlinecode"><span class="id" title="var">update</span></span>, while on all other indices it passes the
    lookup to the function that was previously stored in the reference.
<pre>
      update = \a:NatArray, \m:Nat, \v:Nat,
                   let oldf = !a in
                   a := (\n:Nat, if equal m n then v else oldf n);
</pre>
 
<div class="paragraph"> </div>

<a id="lab431"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 References to values containing other references can also be very
    useful, allowing us to define data structures such as mutable
    lists and trees. 
</div>

<div class="doc">
<a id="lab432"></a><h2 class="section">Null References</h2>

<div class="paragraph"> </div>

 One more difference between our references and C-style
    mutable variables: <i>null pointers</i>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> In C, a pointer variable can contain either a valid pointer
        into the heap or the special value <span class="inlinecode"><span class="id" title="var">NULL</span></span>

<div class="paragraph"> </div>


</li>
<li> A source of many errors and much tricky reasoning
<ul class="doclist">
<li> (any pointer may potentially be "not there")

</li>
<li> but occasionally useful

<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> Null pointers are easy to implement here using references
        plus options (which can be built out of disjoint sum types)
<pre>
            Option T       =  Unit + T
            NullableRef T  =  Ref (Option T)
</pre>

</li>
</ul>

</div>

<div class="doc">
<a id="lab433"></a><h2 class="section">Garbage Collection</h2>

<div class="paragraph"> </div>

 A last issue that we should mention before we move on with formalizing
    references is storage <i>de</i>-allocation.  We have not provided any
    primitives for freeing reference cells when they are no longer needed.
    Instead, like many modern languages (including OCaml, Haskell, Java,
    etc.) we rely on the run-time system to perform <i>garbage collection</i>,
    automatically identifying and reusing cells that can no longer be
    reached by the program. 
<div class="paragraph"> </div>

<a id="lab434"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 This is <i>not</i> just a question of taste in language design: it is
    extremely difficult to achieve type safety in the presence of an
    explicit deallocation operation.  One reason for this is the
    familiar <i>dangling reference</i> problem: we allocate a cell holding
    a number, save a reference to it in some data structure, use it
    for a while, then deallocate it and allocate a new cell holding a
    boolean, possibly reusing the same storage.  Now we can have two
    names for the same storage cell -- one with type <span class="inlinecode"><span class="id" title="var">Ref</span></span> <span class="inlinecode"><span class="id" title="var">Nat</span></span> and the
    other with type <span class="inlinecode"><span class="id" title="var">Ref</span></span> <span class="inlinecode"><span class="id" title="var">Bool</span></span>. 
</div>

<div class="doc">
<a id="lab435"></a><h1 class="section">Operational Semantics</h1>

</div>

<div class="doc">
<a id="lab436"></a><h2 class="section">Locations</h2>

<div class="paragraph"> </div>

 A reference names a location in the <i>store</i> (a.k.a. heap).

<div class="paragraph"> </div>

    What is the store?

<div class="paragraph"> </div>

<ul class="doclist">
<li> Concretely: An array of 8-bit bytes, indexed by 32-bit integers.

<div class="paragraph"> </div>


</li>
<li> More abstractly: a list or array, of values

<div class="paragraph"> </div>


</li>
<li> Even more abstractly: a partial function from locations to values.

</li>
</ul>

<div class="paragraph"> </div>

    We'll choose the middle way here: A store is a list of values, and
    a location is a natural-number index into this list.

</div>

<div class="doc">
<a id="lab437"></a><h2 class="section">Stores</h2>

<div class="paragraph"> </div>

 A store is just a <i>list</i> of values.  (This more concrete
    representation will be more convenient for proofs than the
    functional representation we used in Imp.) 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">store</span> := <span class="id" title="var">list</span> <span class="id" title="var">tm</span>.<br/>
</div>

<div class="doc">
We use <span class="inlinecode"><span class="id" title="var">store_lookup</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">st</span></span> to retrieve the value of the reference
    cell at location <span class="inlinecode"><span class="id" title="var">n</span></span> in the store <span class="inlinecode"><span class="id" title="var">st</span></span>.  Note that we must give a
    default value to <span class="inlinecode"><span class="id" title="var">nth</span></span> in case we try looking up an index which is
    too large. (In fact, we will never actually do this, but <i>proving</i>
    that we don't will require a bit of work.) 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">store_lookup</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">st</span>:<span class="id" title="var">store</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">nth</span> <span class="id" title="var">n</span> <span class="id" title="var">st</span> &lt;{ <span class="id" title="var">unit</span> }&gt;.<br/>
</div>

<div class="doc">
<a id="lab438"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 To update the store, we use the <span class="inlinecode"><span class="id" title="tactic">replace</span></span> function, which replaces
    the contents of a cell at a particular index. 
</div>
<div class="code">

<span class="id" title="keyword">Fixpoint</span> <span class="id" title="tactic">replace</span> {<span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>} (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">x</span>:<span class="id" title="var">A</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span>    ⇒ <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span>    ⇒ <span class="id" title="var">x</span> :: <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> ⇒ <span class="id" title="var">h</span> :: <span class="id" title="tactic">replace</span> <span class="id" title="var">n'</span> <span class="id" title="var">x</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab439"></a><h2 class="section">Reduction</h2>

<div class="paragraph"> </div>

 First, we augment existing reduction rules with stores:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">value v<sub>2</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (ST_AppAbs) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">(\x:T<sub>2</sub>,t<sub>1</sub>) v<sub>2</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> [x:=v<sub>2</sub>]t<sub>1</sub> / st</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">t<sub>1</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> t<sub>1</sub>' / st'</td>
  <td class="infrulenamecol" rowspan="3">
    (ST_App1) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">t<sub>1</sub> t<sub>2</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> t<sub>1</sub>' t<sub>2</sub> / st'</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">value v<sub>1</sub>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t<sub>2</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> t<sub>2</sub>' / st'</td>
  <td class="infrulenamecol" rowspan="3">
    (ST_App2) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">v<sub>1</sub> t<sub>2</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> v<sub>1</sub> t<sub>2</sub>' / st'</td>
  <td></td>
</tr>
</table></center>
<div class="paragraph"> </div>

<a id="lab440"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Now we can give the rules for the new constructs:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (ST_RefValue) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ref v / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> loc |st| / st,v</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">t<sub>1</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> t<sub>1</sub>' / st'</td>
  <td class="infrulenamecol" rowspan="3">
    (ST_Ref) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ref t<sub>1</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> ref t<sub>1</sub>' / st'</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">l < |st|</td>
  <td class="infrulenamecol" rowspan="3">
    (ST_DerefLoc) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">!(loc l) / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> lookup l st / st</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">t<sub>1</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> t<sub>1</sub>' / st'</td>
  <td class="infrulenamecol" rowspan="3">
    (ST_Deref) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">!t<sub>1</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> !t<sub>1</sub>' / st'</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">l < |st|</td>
  <td class="infrulenamecol" rowspan="3">
    (ST_Assign) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">loc l := v / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> unit / replace l v st</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">t<sub>1</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> t<sub>1</sub>' / st'</td>
  <td class="infrulenamecol" rowspan="3">
    (ST_Assign1) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">t<sub>1</sub> := t<sub>2</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> t<sub>1</sub>' := t<sub>2</sub> / st'</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">t<sub>2</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> t<sub>2</sub>' / st'</td>
  <td class="infrulenamecol" rowspan="3">
    (ST_Assign2) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">v<sub>1</sub> := t<sub>2</sub> / st <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> v<sub>1</sub> := t<sub>2</sub>' / st'</td>
  <td></td>
</tr>
</table></center>
</div>

<div class="doc">
<a id="lab441"></a><h1 class="section">Typing</h1>

<div class="paragraph"> </div>

 The contexts assigning types to free variables are exactly the
    same as for the STLC: partial maps from identifiers to types. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="keyword">context</span> := <span class="id" title="var">partial_map</span> <span class="id" title="var">ty</span>.<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab442"></a><h2 class="section">Store typings</h2>

<div class="paragraph"> </div>

 Naturally, the key question is, "What is the type of a location?" 
<div class="paragraph"> </div>

 As a first try, observe that the type of a location is
    connected to the contents of the store <span class="inlinecode">[<span class="id" title="var">st</span>]</span>.

<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Gamma <span class="nowrap">&vert;--</span> lookup  l st : T<sub>1</sub></td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma <span class="nowrap">&vert;--</span> loc l : Ref T<sub>1</sub></td>
  <td></td>
</tr>
</table></center>  But where does <span class="inlinecode">[<span class="id" title="var">st</span>]</span> come from? <a id="lab443"></a><h3 class="section"> </h3>
 We could try adding <span class="inlinecode"><span class="id" title="var">st</span></span> to the judgment: <span class="inlinecode"><span class="id" title="var">Gamma</span>;</span> <span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode"><span class="nowrap">&vert;--</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span>,
    which gives us this rule:

<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Gamma; st <span class="nowrap">&vert;--</span> lookup l st : T<sub>1</sub></td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma; st <span class="nowrap">&vert;--</span> loc l : Ref T<sub>1</sub></td>
  <td></td>
</tr>
</table></center>  But that means the <i>whole</i> store <span class="inlinecode"><span class="id" title="var">st</span></span>, including all dynamically
    created values, is needed <i>during typechecking</i>.  This does not seem
    like something we want.

<div class="paragraph"> </div>

    Worse yet, it doesn't work at all for <i>cyclic</i> stores.
 For example, what is the type of location <span class="inlinecode">0</span> in the
    following store? 
<div class="paragraph"> </div>

<pre>
   [\x:Nat, (!(loc 1)) x, \x:Nat, (!(loc 0)) x]
</pre>
<a id="lab444"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Instead, we establish an <i>invariant</i> that the type of
    value stored in a location never changes.

<div class="paragraph"> </div>

     This <i>static</i>
    representation of the store contents is called a <i>store typing</i>: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">store_ty</span> := <span class="id" title="var">list</span> <span class="id" title="var">ty</span>.<br/>
</div>

<div class="doc">
    Here we represent locations as indices into a <i>list</i> of types so
    the type at index <span class="inlinecode"><span class="id" title="var">i</span></span> is the type of the values stored in cell <span class="inlinecode"><span class="id" title="var">i</span></span>.

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="var">store_Tlookup</span></span> function retrieves the type at a particular
    index. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">store_Tlookup</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">ST</span>:<span class="id" title="var">store_ty</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">nth</span> <span class="id" title="var">n</span> <span class="id" title="var">ST</span> &lt;{ <span class="id" title="var">Unit</span> }&gt;.<br/>
</div>

<div class="doc">
<a id="lab445"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can use the store typing <span class="inlinecode"><span class="id" title="var">ST</span></span> to give a type to
    any location <span class="inlinecode"><span class="id" title="var">l</span></span> like this:
 
<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">l < |ST|</td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma; ST <span class="nowrap">&vert;--</span> loc l : Ref (store_Tlookup l ST)</td>
  <td></td>
</tr>
</table></center> 
</div>

<div class="doc">
<a id="lab446"></a><h2 class="section">The Typing Relation</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">l < |ST|</td>
  <td class="infrulenamecol" rowspan="3">
    (T_Loc) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma; ST <span class="nowrap">&vert;--</span> loc l : Ref (store_Tlookup l ST)</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Gamma; ST <span class="nowrap">&vert;--</span> t<sub>1</sub> : T<sub>1</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (T_Ref) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma; ST <span class="nowrap">&vert;--</span> ref t<sub>1</sub> : Ref T<sub>1</sub></td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Gamma; ST <span class="nowrap">&vert;--</span> t<sub>1</sub> : Ref T<sub>1</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (T_Deref) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma; ST <span class="nowrap">&vert;--</span> !t<sub>1</sub> : T<sub>1</sub></td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Gamma; ST <span class="nowrap">&vert;--</span> t<sub>1</sub> : Ref T<sub>2</sub></td>
  <td></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma; ST <span class="nowrap">&vert;--</span> t<sub>2</sub> : T<sub>2</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (T_Assign) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Gamma; ST <span class="nowrap">&vert;--</span> t<sub>1</sub> := t<sub>2</sub> : Unit</td>
  <td></td>
</tr>
</table></center>
</div>

<div class="doc">
<a id="lab447"></a><h1 class="section">Properties</h1>

<div class="paragraph"> </div>

 Standard theorems...
<ul class="doclist">
<li> Progress -- pretty much same as always

</li>
<li> Preservation -- needs to be stated more carefully! 

</li>
</ul>
</div>

<div class="doc">
<a id="lab448"></a><h2 class="section">Well-Typed Stores</h2>

<div class="paragraph"> </div>

 Evaulation and typing relations take more parameters now,
    so at a minumum we have to add these to the statement of
    preservation... 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">preservation_wrong1</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ST</span> <span class="id" title="var">T</span> <span class="id" title="var">t</span> <span class="id" title="var">st</span> <span class="id" title="var">t'</span> <span class="id" title="var">st'</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">empty</span> ; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t</span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">t</span> / <span class="id" title="var">st</span> <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" title="var">t'</span> / <span class="id" title="var">st'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">empty</span> ; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t'</span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
Obviously wrong: no relation between assumed store typing
    and provided store! 
<div class="paragraph"> </div>

<a id="lab449"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We need a way of saying "this store satisfies the assumptions of
    that store typing"... 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">store_well_typed</span> (<span class="id" title="var">ST</span>:<span class="id" title="var">store_ty</span>) (<span class="id" title="var">st</span>:<span class="id" title="var">store</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> <span class="id" title="var">ST</span> = <span class="id" title="var">length</span> <span class="id" title="var">st</span> ∧<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>, <span class="id" title="var">l</span> &lt; <span class="id" title="var">length</span> <span class="id" title="var">st</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">empty</span>; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> { <span class="id" title="var">store_lookup</span> <span class="id" title="var">l</span> <span class="id" title="var">st</span> } \<span class="id" title="keyword">in</span> {<span class="id" title="var">store_Tlookup</span> <span class="id" title="var">l</span> <span class="id" title="var">ST</span> }).<br/>
</div>

<div class="doc">
Informally, we will write <span class="inlinecode"><span class="id" title="var">ST</span></span> <span class="inlinecode"><span class="nowrap">&vert;--</span></span> <span class="inlinecode"><span class="id" title="var">st</span></span> for <span class="inlinecode"><span class="id" title="var">store_well_typed</span></span> <span class="inlinecode"><span class="id" title="var">ST</span></span> <span class="inlinecode"><span class="id" title="var">st</span></span>. 
<div class="paragraph"> </div>

<a id="lab450"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can now state something closer to the desired preservation
    property: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">preservation_wrong2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ST</span> <span class="id" title="var">T</span> <span class="id" title="var">t</span> <span class="id" title="var">st</span> <span class="id" title="var">t'</span> <span class="id" title="var">st'</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">empty</span> ; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t</span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">t</span> / <span class="id" title="var">st</span> <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" title="var">t'</span> / <span class="id" title="var">st'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">store_well_typed</span> <span class="id" title="var">ST</span> <span class="id" title="var">st</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">empty</span> ; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t'</span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
This works... for all but <i>one</i> of the reduction rules! 
</div>

<div class="doc">
<a id="lab451"></a><h2 class="section">Extending Store Typings</h2>

<div class="paragraph"> </div>

 Intuition: Since the store can grow during reduction, we
    need to let the store typing grow too... 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">extends</span> : <span class="id" title="var">store_ty</span> → <span class="id" title="var">store_ty</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">extends_nil</span>  : <span class="id" title="keyword">∀</span> <span class="id" title="var">ST'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extends</span> <span class="id" title="var">ST'</span> <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">extends_cons</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">ST'</span> <span class="id" title="var">ST</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extends</span> <span class="id" title="var">ST'</span> <span class="id" title="var">ST</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extends</span> (<span class="id" title="var">x</span>::<span class="id" title="var">ST'</span>) (<span class="id" title="var">x</span>::<span class="id" title="var">ST</span>).<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab452"></a><h2 class="section">Preservation, Finally</h2>

<div class="paragraph"> </div>

 We can now give the final, correct statement of the type
    preservation property: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">preservation_theorem</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">ST</span> <span class="id" title="var">t</span> <span class="id" title="var">t'</span> <span class="id" title="var">T</span> <span class="id" title="var">st</span> <span class="id" title="var">st'</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">empty</span> ; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t</span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">store_well_typed</span> <span class="id" title="var">ST</span> <span class="id" title="var">st</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">t</span> / <span class="id" title="var">st</span> <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" title="var">t'</span> / <span class="id" title="var">st'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">ST'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">extends</span> <span class="id" title="var">ST'</span> <span class="id" title="var">ST</span> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">empty</span> ; <span class="id" title="var">ST'</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t'</span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T</span> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">store_well_typed</span> <span class="id" title="var">ST'</span> <span class="id" title="var">st'</span>.<br/>
</div>

<div class="doc">
Note that this gives us just what we need to "turn the
    crank" when applying the theorem to multi-step reduction
    sequences. 
</div>

<div class="doc">
<a id="lab454"></a><h2 class="section">Assignment Preserves Store Typing</h2>

<div class="paragraph"> </div>

 Next, we must show that replacing the contents of a cell in the
    store with a new value of appropriate type does not change the
    overall type of the store.  (This is needed for the <span class="inlinecode"><span class="id" title="var">ST_Assign</span></span>
    rule.) 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">assign_pres_store_typing</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ST</span> <span class="id" title="var">st</span> <span class="id" title="var">l</span> <span class="id" title="var">t</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">l</span> &lt; <span class="id" title="var">length</span> <span class="id" title="var">st</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">store_well_typed</span> <span class="id" title="var">ST</span> <span class="id" title="var">st</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">empty</span> ; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t</span> \<span class="id" title="keyword">in</span> {<span class="id" title="var">store_Tlookup</span> <span class="id" title="var">l</span> <span class="id" title="var">ST</span>} →<br/>
&nbsp;&nbsp;<span class="id" title="var">store_well_typed</span> <span class="id" title="var">ST</span> (<span class="id" title="tactic">replace</span> <span class="id" title="var">l</span> <span class="id" title="var">t</span> <span class="id" title="var">st</span>).<br/>
<div class="togglescript" id="proofcontrol10" onclick="toggleDisplay('proof10');toggleDisplay('proofcontrol10')"><span class="show"></span></div>
<div class="proofscript" id="proof10" onclick="toggleDisplay('proof10');toggleDisplay('proofcontrol10')">
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">ST</span> <span class="id" title="var">st</span> <span class="id" title="var">l</span> <span class="id" title="var">t</span> <span class="id" title="var">Hlen</span> <span class="id" title="var">HST</span> <span class="id" title="var">Ht</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">HST</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">length_replace</span>...<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l'</span> <span class="id" title="var">Hl'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">l'</span> =? <span class="id" title="var">l</span>) <span class="id" title="var">eqn</span>: <span class="id" title="var">Heqll'</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l'&nbsp;=&nbsp;l&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eqb_eq</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Heqll'</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">lookup_replace_eq</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l'&nbsp;&lt;&gt;&nbsp;l&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eqb_neq</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Heqll'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">lookup_replace_neq</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">length_replace</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hl'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>0</sub></span>...<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a id="lab455"></a><h2 class="section">Weakening for Stores</h2>

<div class="paragraph"> </div>

 Finally, we need a lemma on store typings, stating that, if a
    store typing is extended with a new location, the extended one
    still allows us to assign the same types to the same terms as the
    original.

<div class="paragraph"> </div>

    (The lemma is called <span class="inlinecode"><span class="id" title="var">store_weakening</span></span> because it resembles the
    "weakening" lemmas found in proof theory, which show that adding a
    new assumption to some logical theory does not decrease the set of
    provable theorems.) 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">store_weakening</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">Gamma</span> <span class="id" title="var">ST</span> <span class="id" title="var">ST'</span> <span class="id" title="var">t</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">extends</span> <span class="id" title="var">ST'</span> <span class="id" title="var">ST</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">Gamma</span> ; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t</span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">Gamma</span> ; <span class="id" title="var">ST'</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t</span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T</span>.<br/>
<div class="togglescript" id="proofcontrol11" onclick="toggleDisplay('proof11');toggleDisplay('proofcontrol11')"><span class="show"></span></div>
<div class="proofscript" id="proof11" onclick="toggleDisplay('proof11');toggleDisplay('proofcontrol11')">
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">H<sub>0</sub></span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;T_Loc&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<span class="id" title="var">extends_lookup</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">ST'</span>)...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">T_Loc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <span class="id" title="var">length_extends</span>...<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a id="lab456"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can use the <span class="inlinecode"><span class="id" title="var">store_weakening</span></span> lemma to prove that if a store is
    well typed with respect to a store typing, then the store extended
    with a new term <span class="inlinecode"><span class="id" title="var">t</span></span> will still be well typed with respect to the
    store typing extended with <span class="inlinecode"><span class="id" title="var">t</span></span>'s type. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">store_well_typed_app</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ST</span> <span class="id" title="var">st</span> <span class="id" title="var">t<sub>1</sub></span> <span class="id" title="var">T<sub>1</sub></span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">store_well_typed</span> <span class="id" title="var">ST</span> <span class="id" title="var">st</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">empty</span> ; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t<sub>1</sub></span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T<sub>1</sub></span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">store_well_typed</span> (<span class="id" title="var">ST</span> ++ <span class="id" title="var">T<sub>1</sub></span>::<span class="id" title="var">nil</span>) (<span class="id" title="var">st</span> ++ <span class="id" title="var">t<sub>1</sub></span>::<span class="id" title="var">nil</span>).<br/>
<div class="togglescript" id="proofcontrol12" onclick="toggleDisplay('proof12');toggleDisplay('proofcontrol12')"><span class="show"></span></div>
<div class="proofscript" id="proof12" onclick="toggleDisplay('proof12');toggleDisplay('proofcontrol12')">
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">store_well_typed</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Hlen</span> <span class="id" title="var">Hmatch</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">app_length</span>, <span class="id" title="var">add_comm</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">app_length</span>, <span class="id" title="var">add_comm</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;types&nbsp;match.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">Hl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">store_lookup</span>, <span class="id" title="var">store_Tlookup</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_lt_eq_dec</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hl</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">Hl</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Hlt</span> | <span class="id" title="var">Heq</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;l&nbsp;&lt;&nbsp;length&nbsp;st&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> &lt;-<span class="id" title="var">Nat.succ_lt_mono</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hlt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> !<span class="id" title="var">app_nth1</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">apply</span> <span class="id" title="var">store_weakening</span> <span class="id" title="keyword">with</span> <span class="id" title="var">ST</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">extends_app</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Hmatch</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hlen</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;l&nbsp;=&nbsp;length&nbsp;st&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">injection</span> <span class="id" title="var">Heq</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Heq</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">app_nth2</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Hlen</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">sub_diag</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">store_weakening</span> <span class="id" title="keyword">with</span> <span class="id" title="var">ST</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">extends_app</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">app_nth2</span>; [|<span class="id" title="var">lia</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">sub_diag</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a id="lab457"></a><h2 class="section">Preservation!</h2>

<div class="paragraph"> </div>

 Now that we've got everything set up right, the proof of
    preservation is actually quite straightforward.  
</div>

<div class="doc">
<a id="lab459"></a><h2 class="section">Progress</h2>

<div class="paragraph"> </div>

 As we've said, progress for this system is pretty easy to prove;
    the proof is very similar to the proof of progress for the STLC,
    with a few new cases for the new syntactic constructs. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="tactic">progress</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ST</span> <span class="id" title="var">t</span> <span class="id" title="var">T</span> <span class="id" title="var">st</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">empty</span> ; <span class="id" title="var">ST</span> <span class="nowrap">&vert;--</span> <span class="id" title="var">t</span> \<span class="id" title="keyword">in</span> <span class="id" title="var">T</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">store_well_typed</span> <span class="id" title="var">ST</span> <span class="id" title="var">st</span> →<br/>
&nbsp;&nbsp;(<span class="id" title="var">value</span> <span class="id" title="var">t</span> ∨ <span class="id" title="tactic">∃</span> <span class="id" title="var">t'</span> <span class="id" title="var">st'</span>, <span class="id" title="var">t</span> / <span class="id" title="var">st</span> <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:6%;'><span style='letter-spacing:-.2em;'>-</span><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" title="var">t'</span> / <span class="id" title="var">st'</span>).<br/>
<div class="togglescript" id="proofcontrol15" onclick="toggleDisplay('proof15');toggleDisplay('proofcontrol15')"><span class="show"></span></div>
<div class="proofscript" id="proof15" onclick="toggleDisplay('proof15');toggleDisplay('proofcontrol15')">
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">ST</span> <span class="id" title="var">t</span> <span class="id" title="var">T</span> <span class="id" title="var">st</span> <span class="id" title="var">Ht</span> <span class="id" title="var">HST</span>. <span class="id" title="var">remember</span> <span class="id" title="var">empty</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Gamma</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">Ht</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">solve_by_invert</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;T_App&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht1p</span> | <span class="id" title="var">Ht1p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;is&nbsp;a&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht1p</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">solve_by_invert</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht2p</span> | <span class="id" title="var">Ht2p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="comment">(*&nbsp;t<sub>2</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht2p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>2</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ (\ <span class="id" title="var">x<sub>0</sub></span> : <span class="id" title="var">T<sub>0</sub></span>, <span class="id" title="var">t<sub>0</sub></span>) <span class="id" title="var">t<sub>2</sub>'</span> }&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht1p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>1</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ <span class="id" title="var">t<sub>1</sub>'</span> <span class="id" title="var">t<sub>2</sub></span> }&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;T_Succ&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht1p</span> | <span class="id" title="var">Ht1p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;is&nbsp;a&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht1p</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [ <span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;is&nbsp;a&nbsp;const&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ {<span class="id" title="var">S</span> <span class="id" title="var">n</span>} }&gt;, <span class="id" title="var">st</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht1p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>1</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ <span class="id" title="var">succ</span> <span class="id" title="var">t<sub>1</sub>'</span> }&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;T_Pred&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht1p</span> | <span class="id" title="var">Ht1p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;is&nbsp;a&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht1p</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;is&nbsp;a&nbsp;const&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ {<span class="id" title="var">n</span> - 1} }&gt;, <span class="id" title="var">st</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht1p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>1</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ <span class="id" title="var">pred</span> <span class="id" title="var">t<sub>1</sub>'</span> }&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;T_Mult&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht1p</span> | <span class="id" title="var">Ht1p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;is&nbsp;a&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht1p</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht<sub>1</sub></span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht2p</span> | <span class="id" title="var">Ht2p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="comment">(*&nbsp;t<sub>2</sub>&nbsp;is&nbsp;a&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht2p</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht<sub>2</sub></span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ {<span class="id" title="var">n</span> × <span class="id" title="var">n<sub>0</sub></span>} }&gt;, <span class="id" title="var">st</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="comment">(*&nbsp;t<sub>2</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht2p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>2</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ <span class="id" title="var">n</span> × <span class="id" title="var">t<sub>2</sub>'</span> }&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht1p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>1</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ <span class="id" title="var">t<sub>1</sub>'</span> × <span class="id" title="var">t<sub>2</sub></span> }&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;T_If<sub>0</sub>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht1p</span> | <span class="id" title="var">Ht1p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;is&nbsp;a&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht1p</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht<sub>1</sub></span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="comment">(*&nbsp;n&nbsp;=&nbsp;0&nbsp;*)</span> <span class="id" title="tactic">∃</span> <span class="id" title="var">t<sub>2</sub></span>, <span class="id" title="var">st</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span> <span class="id" title="tactic">∃</span> <span class="id" title="var">t<sub>3</sub></span>, <span class="id" title="var">st</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht1p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>1</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ <span class="id" title="var">if<sub>0</sub></span> <span class="id" title="var">t<sub>1</sub>'</span> <span class="id" title="keyword">then</span> <span class="id" title="var">t<sub>2</sub></span> <span class="id" title="keyword">else</span> <span class="id" title="var">t<sub>3</sub></span> }&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;T_Ref&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht1p</span> | <span class="id" title="var">Ht1p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht1p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>1</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{<span class="id" title="var">ref</span> <span class="id" title="var">t<sub>1</sub>'</span>}&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;T_Deref&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht1p</span> | <span class="id" title="var">Ht1p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;is&nbsp;a&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht1p</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">solve_by_invert</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eexists</span>. <span class="id" title="tactic">eexists</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ST_DerefLoc</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">HST</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht1p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>1</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ ! <span class="id" title="var">t<sub>1</sub>'</span> }&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;T_Assign&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht1p</span>|<span class="id" title="var">Ht1p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;is&nbsp;a&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IHHt2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Ht2p</span>|<span class="id" title="var">Ht2p</span>]...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="comment">(*&nbsp;t<sub>2</sub>&nbsp;is&nbsp;a&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht1p</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">solve_by_invert</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eexists</span>. <span class="id" title="tactic">eexists</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ST_Assign</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">HST</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht<sub>1</sub></span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H<sub>4</sub></span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="comment">(*&nbsp;t<sub>2</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht2p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>2</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ <span class="id" title="var">t<sub>1</sub></span> := <span class="id" title="var">t<sub>2</sub>'</span> }&gt;, <span class="id" title="var">st'</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;t<sub>1</sub>&nbsp;steps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht1p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">t<sub>1</sub>'</span> [<span class="id" title="var">st'</span> <span class="id" title="var">Hstep</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> &lt;{ <span class="id" title="var">t<sub>1</sub>'</span> := <span class="id" title="var">t<sub>2</sub></span> }&gt;, <span class="id" title="var">st'</span>...<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a id="lab460"></a><h1 class="section">References and Nontermination</h1>

<div class="paragraph"> </div>

 An important fact about the STLC (proved in chapter <a href="Norm.html"><span class="inlineref">Norm</span></a>) is
    that it is is <i>normalizing</i> -- that is, every well-typed term can
    be reduced to a value in a finite number of steps.

<div class="paragraph"> </div>

    What about STLC + references?  Surprisingly, adding references
    causes us to lose the normalization property: there exist
    well-typed terms in the STLC + references which can continue to
    reduce forever, without ever reaching a normal form! 
<div class="paragraph"> </div>

<a id="lab461"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 How can we construct such a term?  The main idea is to make a
    function which calls itself.  We first make a function which calls
    another function stored in a reference cell; the trick is that we
    then smuggle in a reference to itself!
<pre>
   (\r:Ref (Unit <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> Unit),
        r := (\x:Unit,(!r) unit); (!r) unit)
   (ref (\x:Unit,unit))
</pre>

</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>